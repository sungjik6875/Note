##### var 키워드로 선언된 변수의 문제점

> ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이다. var 키워드로 선언된 변수는 아래와 같은 특징을 갖는다. 

> ##### 함수 레벨 스코프
>
> 코드 블록의 제한을 받지 않아 for loop에서 초기화로 사용된 변수도 loop의 외부나 전역에서 참조가 가능하다는 문제가 있다.

> ##### var 키워드 생략 허용
>
> 전역 변수가 허용된다.

> ##### 중복 선언 허용
>
> 개발자가 의도하지 않은 변수값의 변경이 가능하다.

> ##### 변수 호이스팅
>
> 변수를 선언하기 전에 참조가 가능하다.

> 이러한 특징으로 인해 var의 사용은 여러 문제를 일으키는 원인이었다. 대부분의 문제는 전역 변수로 인해 발생되었다. 전역 변수의 스코프로 인해 변수의 값이 변경되거나, 의도치 않게 사용되는 경우가 있었기 때문이다. 
>
> 변수의 스코프가 넓으면 위와 같이 여러 문제점이 발생한다. 따라서 ES6에서는 이러한 var의 단점을 보완하기 위해 블록 레벨 스코프를 갖는 let과 const 키워드를 도입하였다.



##### ※ Scope

> 자바스크립트에서 키워드로 선언된 변수는 함수 레벨 스코프와 블록 레벨 스코프를 갖는다. 각 스코프의 의미는 다음과 같다.

> ##### 함수 레벨 스코프
>
> 함수내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.

> ##### 블록 레벨 스코프
>
> 코드 블록(함수, if문, for문, while문, try/catch 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 코드 블록 내에서 선언한 변수는 지역 변수이다.





#### let

------

> let의 특징은 다음과 같다.



##### 블록 레벨 스코프

> 함수 레벨 스코프를 갖는 var와 달리 let은 블록 레벨 스코프를 갖는다. var와 let의 차이는 다음 예시로 확인할 수 있다.

```js
// var 

var foo = 123; // 전역 변수
console.log(foo); // 123
{
  var foo = 456; // 전역 변수
}
console.log(foo); // 456



// let

let foo = 123; // 전역 변수
{
  let foo = 456; // 지역 변수
  let bar = 456; // 지역 변수
}
console.log(foo); // 123
console.log(bar); // ReferenceError: bar is not defined
```

> var는 함수 레벨 스코프를 따르기 때문에 코드 블록 내부에서 선언되거나 값이 할당되어도 코드 블록 외부에서 변수와 할당된 값을 참조할 수 있다. 그러나 let은 블록 레벨 스코프이므로 블록 내부에서 선언되거나 값이 할당되면 외부에서 이를 참조할 수 없다.



##### 변수 중복 선언 금지

> var는 동일한 이름의 변수를 중복 선언하는 것이 가능하였다. 그러나 let은 동일한 이름의 변수를 재선언하는 것이 불가능하다. 다만 동일한 변수에 값의 재할당은 가능하다.

```js
var foo = 123;
var foo = 456;  // 중복 선언 허용

let bar = 123;
let bar = 456;  // Uncaught SyntaxError: Identifier 'bar' has already been declared
```



##### 호이스팅 적용

> let도 var와 마찬가지로 호이스팅이 적용된다. 그러나 var와는 분명 다르게 동작하는데, 이는 다음에 설명할 변수의 생성 과정에서 var와 다르기 때문이다.



##### let의 생성 과정

> 자바스크립트에서 변수의 생성 과정은 선언, 초기화, 할당의 세 단계로 나뉜다. var는 선언과 초기화가 한꺼번에 이루어지며, 이후 값이 할당된다. let의 경우 선언과 초기화의 단계도 별도의 과정으로 분리된다. 선언이 먼저 이루어진 후, 이후에 선언문에 도달 시에 초기화가 이루어진다. 
>
> 이로 인해 let은 선언문 이전에 let으로 선언된 변수를 참조하게 될 경우 선언은 되었지만 메모리가 할당되어 값이 undefined로 초기화가 적용되기 전이다. 결국 메모리가 할당되지 않았으므로, 참조 에러를 발생시킨다.
>
> 위의 이유로 let으로 선언된 변수를 참조하기 위해서는 선언문 이후에 참조해야 한다.

```js
// 스코프의 선두에서 선언 단계가 실행된다.
// 그러나 변수가 초기화(메모리 공간 확보와 undefined로 초기화)되지 않았다.
// 따라서 변수 선언문 이전에 변수를 참조할 수 없다.

console.log(foo); // ReferenceError: foo is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행된다.
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 1
```

> 다만 변수의 선언 자체는 호이스팅으로 인해 스코프의 선두에서 이루어진다. 이때 변수가 선언된 시점인 스코프의 선두와 초기화 단계가 진행되는 변수 선언문 사이를 **일시적 사각지대**라 한다.
>
> 이는 마치 let이 호이스팅이 적용되지 않는 것처럼 보이지만 아래의 예시를 보면 let도 호이스팅이 적용되는 것을 확인할 수 있다.

```js
let foo = 1; // 전역 변수

{
  console.log(foo); 
    // Uncaught ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```

> 위의 console.log는 참조 에러를 일으킨다. 만약 let이 호이스팅에 적용받지 않는다면 전역 변수 foo의 값인 1이 콘솔에 출력되어야 할 것이다. 그러나 호이스팅이 적용되어 console.log의 foo는 전역변수 foo가 아닌 지역변수 foo를 가리키게 된다. 아직 foo의 초기화 단계가 이루어지기 전이므로 위와 같은 에러를 일으킨다.



##### 전역 객체와 let

> 전역 객체는 모든 객체의 유일한 최상위 객체를 말한다. 브라우저 상에서는 window 객체, node 환경에서는 global 객체를 의미한다. var로 전역 변수를 선언하면 해당 변수를 최상위 객체의 프로퍼티를 통해 접근할 수 있다.

```js
var foo = 123; // 전역변수
console.log(window.foo); // 123
```

> 반면 let으로 선언된 변수는 전역 변수로 사용하여도 최상위 객체의 프로퍼티가 되지 않는다. 따라서 위와 같이 접근할 수 없다. let 전역 변수는 보이지 않느 개념적인 블록 내에 존재한다.

```js
let foo = 123; // 전역변수
console.log(window.foo); // undefined
```



##### 클로저

> 클로저 이후 추가.





#### const

------

> const는 상수를 위해 사용한다. 하지만 반드시 상수만을 위해 사용하는 것은 아니다. const 역시 블록 레벨 스코프를 가지며, 대부분의 특징이 let과 동일하지만 다른 점들도 있다. const가 let과 다른 점은 다음과 같다.



##### 선언과 초기화

```js
const FOO; // SyntaxError: Missing initializer in const declaration
```

> const는 선언과 동시에 값의 할당이 이루어져야 한다. 그렇지 않으면 위의 예시와 같이 문법 오류를 일으킨다.



##### 값의 재할당 금지

```js
const FOO = 123;
FOO = 456; // TypeError: Assignment to constant variable.
```

> let과 다르게 const는 값의 재할당이 금지되어 상수로 사용된다. 따라서 위의 예시는 문법 오류를 일으킨다. 
>
> const가 갖는 값의 재할당 금지라는 특징은 객체에서는 조금 다르게 작용한다. 변수의 데이터타입이 객체일 경우 실제 변수에 할당되는 실제값은 객체가 존재하는 메모리 주소일 것이다. 값의 재할당 금지는 곧 이 메모리 주소의 값을 변경할 수 없다는 의미이다. 따라서 const로 선언된 변수는 다른 객체를 참조하는 것이 불가능하다. 
>
> 그러나 객체의 프로퍼티를 변경하는 것은 가능하다. 이는 객체의 내용이 변경되더라도 객체에 할당된 메모리 주소값은 변경되지 않기 때문이다. 따라서 참조하고자 하는 객체를 변경하고자 할 때에는 let을 선언해야 하겠지만, 일반적으로 객체는 const를 사용하여 선언한다.





