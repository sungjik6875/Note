#### Operator

------

> 연산자는 하나 이상의 표현식을 대상으로 산술, 할당,  비교, 논리, 타입 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다. 피연산자에는 단순한 값이 올 수도 있지만 하나의 값으로 평가되는 표현식도 올 수 있다.
>
> 피연산자가 값이라는 명사의 역할을 한다면, 연산자는 값을 만드는 동사의 역할을 한다. 피연산자는 연산의 대상이므로 값으로 평가할 수 있어야 한다. 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만들어낸다.
>
> 연산의 종류별 예시는 다음과 같다.

```js
// 산술 연산자
var area = 5 * 4; // 20

// 문자열 연결 연산자
var str = 'My name is ' + 'Lee'; // "My name is Lee"

// 할당 연산자
var color = 'red'; // "red"

// 비교 연산자
var foo = 3 > 5; // false

// 논리 연산자
var bar = (5 > 3) && (2 < 4);  // true

// 타입 연산자
var type = typeof 'Hi'; // "string"

// 인스턴스 생성 연산자
var today = new Date(); // Sat Dec 01 2018 00:57:19 GMT+0900 (한국 표준시)
```



##### ※ implicit type coercion

> 산술 연산등과 같은 두 개의 피연산자를 연산하는 과정에서 두 피연산자의 타입을 반드시 일치시키지 않아도 된다. 이때 암시적으로 연산을 실행시키기 위해 타입 변환이 일어나는데, 이를 암묵적 타입 변환이라 한다.
>
> 암묵적 타입 변환의 예시는 다음과 같다.

```js
var foo = 1 + '10'; // '110'
var bar = 1 * '10'; // 10
```



##### 산술 연산자

> 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산을 할 수 없을 경우에는 NaN을 반환한다.
>
> 산술 연산자는 피연산자의 수에 따라 이항과 단항 산술 연산자로 구분한다.



> ##### 이항 산술 연산자
>
> 2개의 피연산자를 대상으로 연산을 수행한다. 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(Side effect)가 없다. 따라서 어떤 연산을 수행하여도 피연산자의 값은 유지되며, 새로운 값만 생성된다.
>
> 이항 산술 연산자에는 **+, -, *, /, %**가 있다. 예시는 다음과 같다.

```js
5 + 2  // 7
5 - 2  // 3
5 * 2  // 10
5 / 2  // 2.5
5 % 2  // 1
```



> ##### 단항 산술 연산자
>
> 1개의 피연산자를 대상으로 연산을 수행한다.
>
> 증가(++)/감소(--) 연산자는 피연산자의 값을 변경하는 부수효과가 있다. 증가, 감소 연산자는 위치에 따라 연산의 순서가 다르다. 피연산자 앞에 위치한 전위 증가/감소 연산자는 다른 연산보다 먼저 수행된다. 피연산자 뒤에 위치한 후위 증가/감소 연산자는 다른 연산을 수행한 후, 피연산자의 값을 변경한다.
>
> 예시는 다음과 같다.

```js
var x = 5, result;

// 선대입 후증가 (Postfix increment operator)
result = x++;
console.log(result, x); // 5 6

// 선증가 후대입 (Prefix increment operator)
result = ++x;
console.log(result, x); // 7 7

// 선대입 후감소 (Postfix decrement operator)
result = x--;
console.log(result, x); // 7 6

// 선감소 후대입 (Prefix decrement operator)
result = --x;
console.log(result, x); // 5 5
```

> **+** 연산자는 음수를 양수로 반전시키지는 않는다. 다만 숫자 타입이 아닌 피연산자에 사용하여 피연산자를 숫자 타입으로 변경한 값을 생성한다. 그러나 피연산자의 타입을 변경하는 것은 아니고 숫자 타이브로 변경된 값을 새로 생성하여 반환한다. 따라서 피연산자의 값이 변경되지는 않는다.
>
> **-** 연산자는 피연산자의 부호를 반전시킨 값을 반환한다. **+** 연산자와 같이 피연산자를 숫자 타입으로 변경한 값을 새로 생성하여 반환한다.
>
> 예시는 다음과 같다.

```js
+10 // 10
+'10' // 10
+true // 1
+false // 0
```

```js
-10 // -10
-'10' // -10
-true // -1
-false // -0
```



##### 문자열 연결 연산자

> **+** 연산자가 이항 연산자로 사용될 때, 피연산자중 하나 이상이 문자열인 경우에는 문자열 연결 연산자로 동작한다. 두 피연산자가 모두 숫자이어야 산술 연산자로 동작한다.
>
> 예시는 다음과 같다.

```js
'1' + '2'      // '12'
'1' + 2       // '12'
1 + 2          // 3
```



##### 할당 연산자

> 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 부수 효과가 있다.
>
> 할당 연산자에는 **=, +=, -=, *=, /=, %= **가 있다. 예시는 다음과 같다.

```js
var x;

x = 10;   // 10
x += 5;   // 15
x -= 5;   // 10
x *= 5;   // 50
x /= 5;   // 10
x %= 5;   // 0

var str = 'My name is ';
str += 'Lee'; // My name is Lee
```

> 할당 연산자의 특징은 할당 연산이 하나의 표현식으로 취급된다는 것이다. 할당 표현식은 할당된 값으로 평가된다. 예시는 다음과 같다.

```js
var x;
console.log(x = 10); // 10
```

> 할당 연산이 하나의 표현식이므로, 다음과 같은 연쇄 할당도 가능하다.

```js
var x, y;
y = x = 10; // 연쇄 할당(Chained assignment)
console.log(x, y); // 10 10
```



##### 비교 연산자

> 비교 연산자는 좌항과 우항의 피연산자를 비교하는 연산을 수행하고, 결과에 따라 불리언 값을 반환한다. 제어문의 조건식에서 주로 사용한다.
>
> 비교 연산자는 연산에 따라 동등 / 일치 비교 연산자와 대소 관계 비교 연산자로 나뉜다.



> ##### 동등 / 일치 비교 연산자
>
> 값을 비교하는 연산자로 **==, !=**가 있으며, 값과 타입을 모두 비교하는 연산자로 **===, !==**가 있다. 값만을 비교하는 연산을 수행할 때에는 암묵적 타입 변환이 일어나므로 주의해야 한다.
>
> 아래는 **==** 연산자의 사용 예시이다.

```js
5 == 5    // true
5 == '5'   //true
5 == 8    // false

'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true
```

> **==, !=** 연산자는 위와 같이 암묵적 타입 변환 후에 값을 비교하여 결과를 반환한다. 이런 동작 방식은 개발자의 의도와는 다른 결과를 만들어낼 가능성이 크므로 사용을 권장하지 않는다.
>
> 엄밀하게 값을 비교하고자 하는 경우에는 타입도 같이 비교하는 연산자인 **===, !==** 를 사용하는 것이 적절하다.  

```js
5 === 5   // true
5 === '5' // false
```

> 그러나 일치 연산에도 예외가 있는데, NaN이 그렇다. NaN은 자신과의 일치 연산 시에 false를 반환하는 유일한 값이다. 따라서 어떤 값이 NaN인지 조사하려면 빌트인 함수인 isNaN을 사용해야 한다.

```js
Nan === Nan // false
isNaN(NaN) // true
```



> ##### 대소 관계 비교 연산자
>
> 두 피연산자의 대소를 비교하여 불리언 값을 반환한다. **>, <, >=, <=** 가 있다.



##### 논리 연산자

> 논리 연산자는 불리언 값의 피연산자를 연산하여 불리언 값을 반환하는 논리연산을 수행한다. 다만 논리합 연산자인 **||**와 논리곱 연산자인 **&&**의 경우 불리언 이외의 값을 반환하는 경우도 있다.
>
> 논리 연산자로는 **||, &&, !** 가 있다. 예시는 다음과 같다.

```js
// 논리합(||) 연산자
true || true   // true
true || false  // true
false || true  // true
false || false // false

// 논리곱(&&) 연산자
true && true   // true
true && false  // false
false && true  // false
false && false // false

// 논리 부정(!) 연산자
!true  // false
!false // true
```

> 논리 연산에서 피연산자가 불리언 값으로 평가되지 않을 경우 암묵적 타입 변환을 통해 불리언 타입으로 변환되기도 한다.



##### 삼항 조건 연산자

> 삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 자바스크립트의 유일한 삼항 연산자이며 부수 효과는 없다. 삼항 조건 연산자의 표현식은 아래와 같다.

```
조건식 ? 조건식이 true시 반환할 값 : 조건식이 false시 반환할 값
```

> 사용 예시는 다음과 같다.

```js
var x = 2;

// x가 짝수이면 '짝수'를 홀수이면 '홀수'를 반환한다.
// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
var result = x % 2 ? '홀수' : '짝수';

console.log(result); // 짝수
```

> 삼항 조건 연산자를 중첩하여 사용하면 더 복잡한 구조의 조건 연산을 구현할 수도 있다.

```js
var num = 2;

// 0은 false로 취급된다.
var kind = num ? (num > 0 ? '양수' : '음수') : '영';
console.log(kind); // 양수
```



> ##### 삼항 조건 연산자와 if / else 문과의 차이점
>
> 삼항 조건 연산자의 로직은 if / else 문으로도 구현이 가능하다. 물론 삼항 조건 연산자의 표현이 더욱 간결하다는 차이가 있다. 그러나 둘의 주요한 차이는 표현식으로 취급되냐의 여부, 즉 값으로 평가가 가능한지의 여부이다.
>
> if / else 문은 표현식이 아닌 문이다. 따라서 값으로 평가될 수 없다. 그러나 삼항 조건 연산자는 값으로 평가할 수 있는 표현식이다. 따라서 삼항 조건 연산자는 다른 표현식의 일부가 될 수 있어 유용하다.



##### 기타 연산자들

> 쉼표 연산자, 그룹 연산자, typeof 연산자 등이 있다.



> ##### 쉼표 연산자
>
> **,** 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

```js
var x, y, z;
x = 1, y = 2, z = 3; // 3
```



> ##### 그룹 연산자
>
> **()** 연산자는 그룹 내의 표현식을 최우선으로 평가한다. 따라서 연산의 순서를 제어하는 데 사용한다.

```js
10 * 2 + 3   // 23
10 * (2 + 3) // 50
```



> ##### typeof 연산자
>
> 피연산자의 데이터타입을 문자열로 반환한다. 그러나 null은 반환되지 않는다. null을 피연산자로 사용하면 object를 반환한다. 함수의 경우 function을 반환한다.
>
> 예시는 다음과 같다.

```js
typeof ''              // "string"
typeof 1               // "number"
typeof NaN             // "number"
typeof true            // "boolean"
typeof undefined       // "undefined"
typeof Symbol()        // "symbol"
typeof null            // "object"
typeof []              // "object"
typeof {}              // "object"
typeof new Date()      // "object"
typeof /test/gi        // "object"
typeof function () {}  // "function"
```

> 그렇다면 어떤 데이터가 null인지를 확인하려면 어떻게 해야할까? 답은 일치 연산자를 사용하는 것이다.

```js
var foo = null;
console.log(typeof foo === null); // false
console.log(foo === null);        // true
```

> 만약 선언되지 않은 식별자를 피연산자로 사용하면 ReferenceError 대신 undefined를 반환한다.

```js
typeof undeclared  // "undefined"
```

