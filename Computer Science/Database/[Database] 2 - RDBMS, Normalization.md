### 관계형 데이터베이스 관리 시스템 (RDBMS)

------

> 데이터베이스에는 여러 종류의 모델이 있다. 그 중 가장 많이 사용되는 모델은 관계형 모델이다. 관계형 모델은 술어 논리와 집합론에 기반을 둔 데이터베이스 모델로, 개체로 이루어진 테이블과 테이블 사이의 관계로 묘사된다. 따라서 이를 개체관계 모델이라고도 한다.
>
> RDBMS는 이러한 관계형 모델을 바탕으로 데이터를 관리하는 시스템을 말한다. 대표적인 것으로 MySQL, PostgreSQL, Oracle 등이 있다.





#### SQL (Structured Query Language)

> SQL은 관계 대수와 관계 논리에 기반한, 데이터 질의어이다. RDBMS의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어이다.
>
> SQL 문법의 종류는 다음 세가지로 크게 구분된다.

##### 데이터 정의 언어 (DDL, Data Definition Language)

> 테이블과 인덱스의 구조를 관리한다. CREATE, DROP, ALTER 등이 있다. CREATE는 테이블, 인덱스, 제약 조건등을 정의한다. DROP은 테이블을 삭제한다. ALTER는 테이블의 정의를 변경한다. 그 외에도 RENAME과 TRUNCATE가 있다.

##### 데이터 조작 언어 (DML, Data Manipulation Language)

> 데이터의 검색, 등록, 갱신, 삭제을 위해 사용된다. 각 목적에 사용되는 언어로 SELECT, INSERT, UPDATE, DELETE가 있다. 

##### 데이터 제어 언어 (DCL, Data Control Language)

> 데이터에 대한 접근을 제어하기 위해 사용된다. 주요 언어로 GRANT와 REVOKE가 있으며 각각 사용자에게 작업 수행 권한을 부여하거나 박탈할 때 사용한다.





#### 정규화 (Normalization)

------

##### ※ 용어의 혼동을 위한 정리

> 이 문서에서 다음의 용어들은 같은 의미로 사용된다.

```
릴레이션 = 관계
애트리뷰트 = 속성
```

> 정규화란 관계형 데이터베이스 설계에서 중복을 최소화하여 데이터를 구조화하는 프로세스를 말한다. 따라서 정규화의 목표는 이상이 있는 관계를 재구성하여 작고 잘 조직된 관계를 설계하는 것이다. 일반적으로 정규화란 크고, 제대로 조작되지 않은 데이터 테이블을 작고 잘 조직된 테이블의 관계로 나누는 것을 말한다. 그리고 이 중 하나의 테이블에서 데이터의 삽입, 삭제, 변경이 일어나면 정의된 관계들로 인해 나머지 테이블로 전파되게 하는 것을 말한다.



##### 정규화가 왜 필요한가?

> 데이터의 규모가 커지고, 관계 또는 구조가 복잡해지면 동일한 정보가 중복 저장되는 등의 이유로 저장 공간을 낭비하게 되고, 데이터 갱신 이상이 발생하게 된다. 동일한 정보를 하나의 릴레이션에는 변경하였으나, 나머지 릴레이션에서는 변경하지 않은 경우 데이터의 일관성이 깨지며, 어떤 데이터가 정확한지 알 수 없게 된다. 이러한 문제를 해결하기 위해 정규화 과정을 거친다. 



##### 갱신 이상이란?

> 데이터를 갱신하는 과정에서 갱신이 제대로 이루어지지 않는 것을 말한다. 충분히 정규화되지 않은 데이터 테이블에선 갱신 이상이 발생할 수 있다. 갱신 이상은 삽입 이상, 삭제 이상, 수정(갱신) 이상이 있으며 개념은 다음과 같다.

* ##### 삽입 이상 (Insertion Anomalies)

> 원하지 않는 자료가 삽입되거나, 삽입 시에 자료가 부족해 삽입이 되지 않는 것을 말한다.

* ##### 삭제 이상 (Deletion Anomalies)

> 자료의 일부만 삭제하려고 하나, 자료가 포함된 튜플 전체가 삭제되어 의도치 않은 정보 손실이 발생하는 것을 말한다.

* ##### 수정 이상 (Modification Anomalies)

> 동일한 정보가 여러 곳에서 중복되어 표현되는 경우, 이 정보의 갱신 시 일부만 갱신되는 현상을 말한다. 이런 경우 데이터의 모순이 발생하게 된다.



##### 나쁜 릴레이션과 정규형, 함수적 종속성

> 이러한 갱신 이상을 방지하기 위해 정규화 작업을 진행한다. 정규화란 결국 관계형 데이터베이스에서 데이터의 중복을 최소화하고, 크고 나쁜 릴레이션의 애트리뷰트를 작고 좋은 릴레이션으로 분해하는 작업이다.
>
> 그런데 나쁜 릴레이션은 어떻게 구분해야 할까? 정규화 작업에서 나쁜 릴레이션을 파악할때 사용되는 개념이 함수적 종속성이다. 정규화에는 여러 유형이 있는데, 이 유형을 판단할 때 함수적 종속성의 만족 유무를 기준으로 삼는다. 어떤 함수적 종속성을 만족하는 지의 여부에 따라 정규형이 결정되고, 만약 정규형에 해당되지 않는 경우 나쁜 릴레이션으로 규정한다.
>
> 정규화를 다르게 말하면 나쁜 릴레이션을 정규형을 만족하는 좋은 관계로 표현하는 것을 의미한다. 그런데 정규형을 이해하기 위해서는 먼저 함수적 종속성과 키의 개념을 이해할 필요가 있다.





#### 함수적 종속성 (Functional Dependency)

------

> X, Y가 관계 R의 속성이라고 가정할 때, 임의의 X가 Y를 유일하게 결정하고, 동일한 Y의 값은 여러 X에 대응될 수 있을 때 Y는 X에 대해 함수 종속이라 하고 X→Y로 표기한다. 즉, X의 값을 알면 X를 통해 Y의 값도 알아낼 수 있음을 의미한다. 이 떄 X를 결정자, Y를 종속자라 한다.

##### 자명한 함수 종속성

> 속성의 집합 U가 있을 때, U의 부분집합 X가 함수 종속성을 갖는 경우 U 역시 함수 종속성을 갖는 것은 자명하다.

##### 부분 함수 종속성 / 완전 함수 종속성 (Partial / Full FD)

> 속성집합 Y가 속성집합 X의 전체집합이 아닌 부분집합에도 함수적으로 종속되는 경우 부분 함수 종속성을 만족한다고 한다. 그러나 속성집합 X 전체에 대해서만 함수적으로 종속되는 경우에는 완전 함수적 종속이라 한다.

##### 이행함수 종속성

> A→B, B→C인 상황에서 A→C인 경우 이행함수 종속이라 한다. 다만 A는 1차 키 이외의 속성이라는 전제를 갖는다.

##### 다치 종속성

> X의 값이 여러 Y값의 집합을 결정하는 경우 Y는 X에 대해 다치 종속이라 한다. 다치 종속은 일반 함수 종속과 구분되어 Double Arrow로 표기된다. 예를 들어 동일한 수업에 여러 명의 강사가 배정된 경우, 강사는 수업에 대해 다치 종속된다고 할 수 있다.

##### 조인 종속성

> 조인 종속이란 릴레이션 R이 R의 부분집합인 A, B, ...의 조인으로 표현될수 있을 때 R이 조인 종속성을 갖는다고 말한다.

> ##### 무손실 조인 / 비부가적 조인
>
> 하나의 릴레이션을 여러 개의 릴레이션으로 분해한 후, 공통 속성으로 조인하였을 때 데이터의 손실이 없이 원래의 릴레이션으로 복원할 수 있으면 무손실 조인이라 한다. 조인한 결과에 원래 릴레이션에 없는 데이터(가짜 데이터)가 존재하지 않으면 이를 비부가적 조인이라 한다.





#### 키

------

> 테이블에서 특정 레코드 또는 튜플을 식별하기 위해 사용되는 데이터를 말한다. 키에는 다음과 같은 세부 개념들이 있다.

##### 일차 키 (Primary Key)

> 레코드 또는 튜플을 식별할 떄 가장 우선적으로 사용되는 키를 말한다. 따라서 레코드의 검색이나 정렬 작업에서 우선적으로 참조된다. 만약 릴레이션 R에서 키 필드가 하나만 존재하는 경우, 자동적으로 그 키는 일차 키가 된다. 만약 키 필드가 여러 개 존재하는 경우 일차 키가 아닌 키를 대체 키라 한다.

##### 슈퍼 키 / 후보 키 (Super / Candidate Key)

> 슈퍼 키란 레코드를 유일하게 식별할 수 있는 속성들의 집합이다. 하나의 테이블은 복수 개의 슈퍼키를 가질 수 있다.
>
> 후보 키란 슈퍼 키에서 식별에 불필요한 속성을 제거한 슈퍼 키의 부분집합이다.





#### 정규형 (NF, Normal Form)

------

##### 제 1 정규형 (1NF)

> 릴레이션의 튜플에 속하는 모든 애트리뷰트의 도메인이 오직 원자값만을 포함하고, 각각의 애트리뷰트는 도메인에 속하는 원자값을 갖는 경우를 말한다. 즉, 복합 애트리뷰트나 다중 애트리뷰트, 중첩 릴레이션 등의 원자성을 만족하지 못하는 애트리뷰트를 허용하지 않는 릴레이션의 형태를 말한다.

##### 제 2 정규형 (2NF)

> 모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 완전 함수적 종속일 때 제 2 정규형을 만족한다고 볼수 있다. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션의 형태를 말한다.

##### 제 3 정규형 (3NF)

> 어떠한 비주요 애트리뷰트도 기본키에 대해 이행적으로 종속되지 않으면 제 3 정규형을 만족한다. 따라서 릴레이션에 존재하는 이행 종속 관계를 분해하면 제 3 정규형에 해당된다.

##### 보이스 코드 정규형 (BCNF, Boyce-Codd NF)

> 여러 후보 키가 존재하는 릴레이션에 적용되는 정규화 내용이다. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있다. 비주요 애트리뷰트가 후보키의 일부를 결정할 경우, 이를 분해하는 과정을 말한다.

##### 제 4 정규형

> 릴레이션 내에 존재하는 다치 종속을 제거하는 경우 제 4 정규형을 만족한다고 볼 수 있다.

##### 제 5 정규형

> 릴레이션 내의 조인 종속성을 제거하는 경우 제 5 정규형을 만족한다고 볼 수 있다. 릴레이션을 여러 개의 릴레이션으로 분해하면서 무손실 조인과 비부가 조인을 만족하면 제 5 정규형에 해당된다. 





#### 정규화의 장단점

------

> 정규화에는 다음과 같은 장단점이 존재한다.



##### 정규화의 장점

> ##### 데이터 변경 시 이상 현상 제거
>
> 앞에서 설명했듯, 갱신 이상을 방지하기 위해 정규화가 사용된다.

> ##### 데이터베이스 구조 확장 시 재 디자인 최소화
>
> 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 애플리케이션에 최소한의 영향만을 미치게 되며 응용프로그램의 생명을 연장시킨다.

> ##### 사용자에게 데이터 모델을 더욱 의미있게 제공
>
> 정규화된 테이블과 정규화된 테이블 간의 관계는 현실에서의 관계를 반영한다.



##### 정규화의 단점

> 릴레이션의 분해로 인해 릴레이션 간의 JOIN 연산이 많아진다. 이로 인해 질의에 대한 응답시간이 느려질 수 있다. 따라서 이러한 이유로 성능저하가 나타나는 경우에는 반정규화 전략을 채택하기도 한다.





#### 반정규화 (De-normalization)

------

> 반정규화는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법이다. 디스크 I/O 량이 많아서 조회 시 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다. 일반적으로 조회에 대한 처리 서능이 중요하다고 판단되면, 부분적으로 반정규화를 고려한다.

##### 반정규화의 적용방법

> 정규화가 많이 적용되면 SQL 문장의 작성이 복잡해지고, 잦은 JOIN 연산으로 성능 저하가 발생할 수 있다. 따라서 이런 경우에 보통 반정규화를 고려한다. 그러나 반정규화를 적용할 경우 성능은 향상되어도, 데이터의 무결성이 깨질 수 있으므로 이를 보완할 수 있는 프로세스가 선행되어야 한다. 따라서 데이터의 무결성을 유지할 수 있는 수준에서 반정규화를 적용하는 것이 이상적이다.



