##### 전송 계층과 프로토콜

> 인터넷은 전송 계층에 연결형 프로토콜과 비연결형 프로토콜, 이렇게 두 개의 주된 프로토콜을 갖는다.



### UDP (User Datagram Protocol, 사용자 데이터그램 프로토콜)

------

> UDP는 비연결형 프로토콜이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.



#### UDP의 사용

* ##### 클라이언트 - 서버 간의 요청 및 응답

> UDP가 유용한 분야는 클라이언트-서버 상황이다. 종종 클라이언트는 서버로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면, 클라이언트는 Time Out되고 다시 시도할 수 있다. 코드가 간단할 뿐 아니라 TCP보다 초기설정에 적은 메시지가 요구된다.



* ##### DNS

> UDP를 사용한 것들 중 DNS가 있다. 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은, DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. DNS 서버가 이러한 요청을 받으면, 호스트의 IP 주소를 포함한 UDP 패킷을 응답으로 보낸다. 이러한 전송에는 사전 설정이 필요하지 않으며, 전송 후에도 해제가 필요하지 않다.



* ##### 실시간 멀티미디어

> UDP는 실시간 멀티미디어에서도 활용된다. 실시간 멀티미디어의 응용이 많아지면서 오디오와 비디오 데이터 패킷 형식으로 전송하는 실시간 전송 프로토콜(RTP: Real-time Transport Protocol)이 탄생했다. RTP의 기본 기능은 UDP 패킷의 단일 스트림으로 몇몇 실시간 데이터 스트림을 멀티플렉싱하는 것이다. UDP 스트림은 단일 목적지 또는 다중 목적지로 전송된다. RTP는 UDP를 기반으로 하므로 데이터의 전달, 지연, 손실 등에 대해 보장해주지 않는다.
>
> 다만 이런 점들을 보완하기 위한 몇 가지 장치들이 존재한다. RTP 스트림에서 보내지는 각 패킷은 전 패킷보다 하나 높은 번호가 주어진다. 이런 번호 부여 방식은 목적지로 하여금 어느 패킷이 분실되었는지 알 수 있게 한다. 만약 어떤 패킷이 손실된 것을 감지하였을 때, 목적지에서 분실된 패킷을 획득하기 위한 최상의 동작은 보간(Interpolation)에 의해 손실된 값에 대한 근사치를 얻는 것이다.
>
> 손실된 패킷에 대해 재전송을 요청하는 것을 어떨까? 실시간 멀티미디어라는 특성상, 재전송을 요청하고, 손실된 패킷을 응답받는 것 까지 소요되는 시간을 고려한다면 유용한 방법은 아닐 것이다. 따라서 RTP는 손실된 패킷에 대해 재전송을 요청하는 메커니즘이 없다.



##### ※ 멀티플렉싱 (Multiplexing)

> 단일 링크를 통해 여러 개의 신호를 동시에 전송할 수 있도록 하는 기술이다. 멀티플렉싱은 크게 주파수분할다중화(FDM)와 파장분할다중화(FDM), 시분할다중화(TDM)의 세 가지 방식으로 나뉜다.





### TCP (Transmission Control Protocol, 전송 제어 프로토콜)

------

> 대부분의 인터넷 응용 분야들은 신뢰성이 보장되고, 순차적인 방식의 정보 전달을 필요로 한다. UDP는 이러한 요구를 충족시키지 못한다. 이러한 요구를 충족시키기 위해 탄생한 프로토콜이 TCP이다.
>
> TCP는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. 각 소켓은 호스트의 IP 주소와 그 호스트에 국한된 16비트로 구성된 포트라고 불리는 소켓 번호를 갖는다. TCP 통신을 하기 위해서는 송신측 소켓과 수신측 소켓이 연결되어 있어야 한다.



#### TCP의 특징

------

* ##### 전이중 (Full-duplex)

* ##### 점대점 (Point to Point)

* ##### 바이트 스트림 (Byte Stream)

> 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 말한다. 점대점이란 각 연결이 정확히 두 개의 종단점을 가지고 있음을 의미한다.  따라서 TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다. 멀티캐스팅과 브로드캐스팅은 모두 다수의 대상을 향해 데이터를 전송하기 때문이다. 그리고 TCP는 메시지 스트림이 아닌 바이트 스트림의 형태를 갖는데, 메시지의 시작에서 끝까지의 경계가 유지되지 않는다.



* ##### 최대 전송량의 제약

> TCP 연결상의 모든 바이트는 고유의 32-비트로 이루어진 순서 번호(Sequence Number)를 갖는다는 점이다. 송수신 TCP 개체들은 세그먼트의 형태로 데이터를 주고 받는다. 하나의 세그먼트는 고정 2바이트의 헤더와 그 뒤를 따르는 0개 이상의 데이터 바이트들로 구성된다. TCP 소프트웨어는 세그먼트가 얼마나 커야 하는지를 결정한다. 세그먼트 크기에는 두 가지 제약요소가 있는데, 하나는 TCP 헤더를 포함하여 IP 수용량인 65,515 바이트를 넘을 수 없다는 것이며 나머지 하나는 모든 네트워크는 정해진 MTU(Maximum Transfer Unit, 최대 전송 단위)를 갖는데 이 MTU를 넘을 수 없다는 것이다.



* ##### 재전송 메커니즘

> TCP 개체들에 의해 사용되는 기본 프로토콜은 동적으로 윈도우 크기를 조절하는 슬라이딩 윈도우(Sliding Window) 프로토콜이다. 송신자는 하나의 세그먼트를 전송할 때, 타이머를 구동시킨다. 그 세그먼트가 목적지에 도달하면, 수신측 TCP 개체는 다음에 받으려는 순서번호와 같은 확인 응답번호를 세그먼트에 포함시켜 송신측에 전달한다. 보낼 데이터가 있다면 같이 포함시킨다.
>
> 만일 확인 응답을 수신측으로부터 수신 받기 전에 구동시켰던 타이머가 종료된다면, 송신자는 해당 세그먼트의 전송이 실패했다고 간주하고, 그 세그먼트를 재전송한다. 세그먼트들이 순서가 뒤바뀐 상태로 도착할 수 있으며, 재전송 경우에 대해 올바르게 수신된 상태인지를 알 수 있도록 장치가 필요하다. 스트림 내의 각 바이트는 고유의 offset을 갖고 있는데, 이를 장치로 활용한다.



* ##### 3-way-handshake

> TCP에서 연결 설정은 3-way-handshake를 통해 행해진다. 하나의 연결을 설정하려면 서버 측은 Listen과 Accept를 실행함으로써 연결 요청을 수동적으로 기다린다. 이 Listen과 Accept는 특정 근원지를 명시할 수도 있고 하지 않을 수도 있다. 클라이언트 측은 Connect를 실행하고 목적지 IP 주소와 포트, 수신 가능한 최대 TCP 세그먼트 크기와 기타 사용자 데이터를 명시한다.





#### 3-way-handshake와 4-way-handshake

------

> TCP에서는 3-way-handshake 방식을 활용하여 연결을 성립시키고, 4-way-handshake 방식을 활용하여 연결을 해제한다. 각 방식에 대한 설명은 다음과 같다. 각 이미지와 설명에 등장하는 용어의 의미는 다음과 같다.

```
SYN : Synchronize Sequence Number
ACK : Acknowledgement
```



##### 3-way-handshake (연결 성립)

> 참고용 이미지는 다음과 같다.

![example_1](./image/network_2_1.png)

> 설명은 다음과 같다.
>
> 서버는 Listen과 Accept를 실행하여 연결 요청을 대기하는 상태에 있다. 클라이언트가 Connect를 실행하여 서버에 접속을 요청하는 SYN(m) 패킷을 보낸다. 서버가 이 요청을 받고 클라이언트에게 요청을 수락한다는 ACK(m+1)과 SYN(n)이 설정된 패킷을 발송한다. 클라이언트가 서버의 수락 응답을 받고 ACK(n+1)를 서버로 보내면 연결이 성립된다.



##### 4-way-handshake (연결 해제)

> 참고용 이미지는 다음과 같다.

![example_1](./image/network_2_2.png)

> 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다. 서버는 클라이언트의 요청을 받고 알겠다는 확인 메시지로 ACK를 보낸다. 그리고 잠시 데이터를 모두 보낼 때 까지 잠깐 TIME_OUT이 된다. 데이터를 모두 보내고 나서 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다. 클라이언트는 FIN 메시지를 확인했다는 의미로 ACK를 다시 서버에 보낸다. 클라이언트의 ACK 메시지를 받은 서버는 소켓 연결을 Close한다. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다. 이를 TIME_WAIT이라 한다.

