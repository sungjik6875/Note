### 동기화 (Synchronization)

------

> 동기화란 동시에 여러 시스템을 작동시키기 위해 사건이나 데이터 등을 일치시키는 것을 말한다. 네트워크, 데이터베이스, GPS 등의 많은 부분에서 사용된다. 그 중 데이터베이스, 은행의 예를 들어보자.
>
> 데이터베이스 상에서 동기화란 데이터의 일치를 의미한다. 은행 서버에 접속하는 클라이언트의 상황을 생각해보자. 클라이언트의 계좌에는 10만원이 있다. 클라이언트가 자신의 계좌에서 10만원을 인출하는 거래를 실행한다고 할 때, 클라이언트와 서버가 데이터가 일치하지 않는다면 서버의 기록에는 방금 전 클라이언트의 인출 정보가 없을 것이다. 이 시간을 이용하여 클라이언트는 10만원을 한 번 더 인출할 수도 있을 것이다. 
>
> 이렇게 되면 클라이언트는 10만원의 계좌로부터 20만원을 인출하게 되므로 오류가 발생한다. 이런 일을 방지하기 위해서는 항상 서버와 클라이언트의 데이터가 일치해야 한다. 이 데이터 일치화를 동기화라고 한다.
>
> 컴퓨터 내부에서도 동기화 작업은 중요하다. 멀티 프로세싱, 멀티 스레딩 시스템에선 각 프로세스 또는 스레드가 공유하는 자원에 동시에 접근하게 되는 경우가 발생하는데, 이 때 동기화 작업을 처리하지 않는다면 오류가 발생하기 때문이다. 따라서 동시에 접근할 경우 각 프로세스 또는 스레드의 접근을 제어할 필요가 있다.





#### 임계영역 (Critical Section)

> 멀티 프로세싱, 멀티 스레딩에서는 여러 프로세스 또는 스레드가 공유하는 자원이 존재한다. 이 공유 자원과 관련된 코드 영역을 임계영역이라 한다. 이 임계영역에 동시에 접근하게 됨으로 인해 문제가 발생하는데, 이 문제를 해결하기 위한 요건은 다음과 같다.





#### 동기화 문제 해결을 위한 요건 (Requirements)

* ##### 상호 배제 (Mutual Exclusion)

> 어떤 프로세스가 임계 영역에서 실행 중이라면, 다른 프로세스는 임계 영역에서 실행될 수 없다.

* ##### 진행 (Progress)

> 임계 영역에서 실행 중인 프로세스가 없는 상태에서, 임계 영역에 진입하고자 하는 프로세스가 여러 개라면 어떤 것이 들어갈 지 적절히 결정해야 한다.

* ##### 한정 대기 (Bounded Waiting)

> 기아(Starvation) 상태에 빠지는 프로세스를 방지하기 위해, 어떤 프로세스가 임계 영역에 진입 신청 후 받아들여질 때까지 다른 프로세스들이 임계역역에 진입하는 횟수는 제한이 있어야 한다.





#### 동기화 제어 방법

* ##### 락 (Lock)

> 뮤텍스라고도 하며, 하드웨어 기반의 해결 방법이다. 동시에 임계영역에 접근하는 것을 막기 위해 임계영역에 진입하는 프로세스는 락을 획득하고, 빠져나올때 락을 방출함으로써 동시에 접근이 되지 않도록 하는 방법이다. 락을 획득해야 접근이 가능하다.
>
> 가장 단순한 락의 유형은 이진 세마포어의 형태이다. 하드웨어 기반의 락은 다중처리 환경에서는 시간적인 효율성 측면에서 적용하기 어렵다는 단점이 있다.

* ##### 세마포어(Semaphores)

> 세마포어는 락과 유사한 원리지만, 보통 소프트웨어 상의 해결 방법을 말한다. 종류는 카운팅 방식과 이진 방식이 있다. 카운팅 방식은 가용한 개수를 가진 자원에 대한 접근 제어 용도로 사용된다. 카운팅 세마포어 변수는 가용한 자원의 개수로 항상 초기화된다. 사용중인 자원이 많을 수록 세마포어의 수는 줄어들고, 자원이 방출될 수록 증가하는 방식이다.
>
> 이진 방식은 뮤텍스라고도 하며, 불리언 형태의 값을 갖는다. 동시에 하나의 프로세스 혹은 스레드만 접근이 가능한 경우에는 이진 방식을 사용한다.

* ##### 모니터 (Monitor)

> 프로세스 또는 스레드를 동기화 하기 위해 구현된 기능이나 모듈을 의미한다. 주로 고급 언어에서 지원하는 기능으로, 한 번에 하나의 프로세스 또는 스레드만 모니터에서 활동하도록 보장한다. 
>
> 어떤 공유 자원에 대해 모니터를 지정하면, 프로세스는 그 자원에 접근하기 위해 모니터에 진입해야 한다. 모니터 내부에 진입한 프로세스에게만 데이터 접근 권한이 주어진다. 프로세스가 모니터에 진입하고자 할 때 다른 프로세스가 모니터 내부에 존재한다면 대기 큐에서 대기한다.
>
> 세마포어가 직접 락의 획득과 해제를 개발자가 처리함으로써 접근을 제어한다면, 모니터는 그러한 기능이 이미 구현된 모듈이다. 따라서 모니터를 지정하기만 하면, 모니터가 자동적으로 락의 획득과 해제를 처리한다.





#### 바쁜 대기 (Busy Waiting)

> 바쁜 대기란 공유 자원에 대해 프로세스 또는 스레드가 이용 권한을 획득하기 위해 대기하는 과정에서 일어나는 현상이다. 임계 영역에 진입해야 하는 프로세스나 스레드는 진입 코드를 진입이 가능할 때 까지 반복 실행해야 한다. 즉, 대기하는 동안 진입 코드가 반복 실행되는데 이로 인해 CPU 시간을 낭비하게 된다.
>
> 그러나 바쁜대기는 공유 자원에 대한 획득이 빠른 시간내에 이루어질 수 있다는 확신이 있으면 사용하기에 적절하다. 뮤텍스나 세마포어 등의 동기화 객체를 이용하기에는 오버헤드가 큰 상황에서 바쁜대기는 간단하게 사용이 가능하다. 
>
> 대표적인 예가 스핀락(Spinlock)으로, 스핀락은 임계 구역에 진입이 불가능할 때, 진입이 가능할 때 까지 루프를 돌면서 재시도하는 방식으로 구현된 락을 말한다. 스핀락은 운영 체제의 스케줄링 지원을 받지 않으므로, 스레드에서는 문맥 교환이 일어나지 않는다. 따라서 스핀락은 임계 구역에 짧은 시간 내로 진입할 수 있는 경우 문맥 교환에 드는 비용을 제거할 수 있어 효율적이다. 그러나 만약 스핀락이 오랜 시간을 소요한다면 다른 스레드가 계속 대기하므로 비효율적이다. 
>
> 위의 이유로 바쁜 대기 방식은 상황에 따라 적절히 선택해야 한다.





#### 데드락 (Deadlock)

> 교착상태라고도 한다. 둘 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리는 상태이다. 그 이유는 둘 이상의 작업이 각각 임계 영역에서 실행 중이기 때문이다. 따라서 결과적으로 아무 작업도 완료되지 못한 채 끊임없이 대기하게 된다.



##### 데드락의 발생 조건

> E. G. 코프만 교수는 교착상태가 발생하기 위해서는 네 가지 필요 조건이 충족되어야 함을 증명하였다. 그 네 가지 조건이란 상호배제, 점유대기, 비선점, 순환대기이다. 이 중 순환대기는 점유대기와 비선점 조건을 만족해야 성립할 수 있는 조건이므로 네 개의 조건이 서로 완전히 독립적인 것은 아니다.

* ##### 상호배제

> 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.

* ##### 점유대기

> 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.

* ##### 비선점

> 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.

* ##### 순환대기 (환형대기)

> 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.



##### 데드락의 예방

> 데드락이 발생하려면 위의 네 가지 조건이 필요함이 증명되었다. 따라서 데드락의 예방은 위의 네 가지 조건 중 하나를 막음으로써 이루어진다. 데드락의 예방은 자원 사용의 효율성을 저하시키고, 비용이 많이 든다는 문제점이 있다. 데드락의 예방 접근방식은 다음과 같다.

* ##### 상호배제 제거

* ##### 점유와 대기 조건의 제거

> 하나의 프로세스가 수행되기 전에 모든 자원을 할당시키고, 점유하지 않을 때에는 다른 프로세스가 자원을 요구하도록 하는 방법이다. 간단하지만, 자원 과다 사용으로 인한 효율성, 프로세스가 요구하는 자원을 파악하는데 드는 비용, 자원에 대한 내용을 저장 및 복원하기 위한 비용, 기아상태, 무한대기 등의 문제점이 있다.

* ##### 비선점 조건의 제거

> 비선점 프로세스에 대해 선점 가능한 프로토콜을 만든다.

* ##### 순환 대기 제거

> 자원 유형에 따라 순서를 매긴다.



##### 데드락의 회피

> 자원이 어떻게 요청될지에 대한 추가정보를 제공하도록 요구하는 것으로 시스템에 순환 대기가 발생하지 않도록 자원 할당상태를 검사한다. 회피에 사용되는 대표적인 알고리즘으로 두 가지가 있다.

* 자원 할당 그래프 알고리즘

* 은행원 알고리즘



##### 데드락의 무시

> 데드락의 예방이나 회피는 프로그래밍의 성능에 큰 영향을 미칠 수 있다. 따라서 데드락의 발생 확률이 비교적 낮다고 판단되면 조치를 취하지 않고 무시하기도 한다.



##### 데드락의 발견

> 데드락을 감시하거나 발견하는 알고리즘을 추가해 데드락의 발생을 확인한다. 예방이나 회피처럼 성능에 큰 영향을 미칠 수 있다.