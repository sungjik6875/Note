### 스코프 (Scope)

------

#### 스코프의 정의 및 필요성

------

##### 이해를 돕기 위한 예시

> 스코프는 유효범위란 의미를 갖는 용어로 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적인 개념이다.
>
> 스코프에 대해 알아보기 전에 아래 예제를 보자.

```javascript
var x = 'global';

function foo () {
    var x = 'function scope';
    console.log(x);
}

foo(); // ?
console.log(x); // ?
```

> 이 예시 코드의 실행 결과는 어떻게 될까?
>
> 이름이 같은 변수 x가 중복 선언되었다. 전역에서 변수 x를 참조할 때, 그리고 함수 foo 내부에서 변수 x를 참조할 때 이름이 중복된 두 개의 변수 중 어떤 변수를 참조해야 할까? 자바스크립트는 이 때 어떤 기준으로 참조할 변수를 선택할 것인가?
>
> 스코프는 이에 대한 기준으로 사용된다. 스코프는 참조 대상 식별자(Identifier, 변수, 함수의 이름)를 찾아내기 위한 기준으로 사용된다. 자바스크립트는 이 스코프를 기준으로 참조할 식별자를 선정한다.



##### 변수의 선언과 스코프의 정의

> 프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공한다. 이를 통해 프로그램의 상태를 관리할 수 있다. 프로그래밍에서 변수는 전역 또는 코드 블록(if, for, while, try/catch 등)이나 함수 내에 선언되며 코드 블록이나 함수는 중첩되는 것이 가능하다. 식별자는 자신이 어디에서 선언되었는지에 따라 자신의 유효범위(다른 코드에서 자신을 참조할 수 있는 범위)를 갖는다.
>
> 위 예시를 기준으로 설명하자면, 전역에서 선언된 변수 x는 어디에서든 참조하는 것이 가능하다. 그러나 함수 foo 내에서 선언된 변수 x는 함수 foo 내에서만 참조하는 것이 가능하다. 함수 외부에서는 참조할 수 없다. 이렇게 변수가 선언된 위치에 따라 변수의 참조 범위가 결정되는 규칙을 스코프라고 한다.



##### 스코프의 필요성

> 만약 스코프가 없다면 어떻게 될까? 스코프가 없다면 같은 식별자 이름을 충돌을 일으키므로 프로그램 전체에서 하나 밖에 사용할 수 없다. 이는 디렉토리가 없는 컴퓨터와 같다. 디렉토리가 없다면 같은 이름을 갖는 파일을 하나 밖에 만들 수 없을 것이다. 스코프도 이와 같이 식별자 이름의 충돌을 방지한다.





#### 스코프의 구분에 따른 변수의 구분

------

> 자바스크립트의 스코프는 전역 스코프와 지역 스코프로 나뉜다.

> ##### 전역 스코프 (Global Scope)
>
> 어디에서든 참조할 수 있다.

> ##### 지역 스코프 (Local Scope / Function-Level Scope)
>
> 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다.



> 위에서 구분한 스코프에 따라 변수도 다음과 같이 구분한다.

> ##### 전역 변수 (Global Variable)
>
> 전역에서 선언된 변수이며 어디서든 이 변수를 참조할 수 있다.

> ##### 지역 변수 (Local Variable)
>
> 지역(함수) 내에서 선언된 변수이며 그 지역과 하부 지역에서만 참조할 수 있다.

> 변수는 선언 위치에 의해 스코프를 갖는다. 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이다.  지역(함수)에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다.





#### 자바스크립트의 스코프

------

##### C 계열 언어의 블록 레벨 스코프

> 자바스크립트의 스코프는 타 언어와는 다른 특징을 갖는다. 대부분의 C 계열 언어에서 변수의 스코프는 블록 레벨 스코프(block-level scope)를 따른다. 블록 레벨 스코프란 코드 블록({...})내에서 유효한 스코프를 의미한다.
>
> C언어 블록 레벨 스코프의 예시는 다음과 같다.

```c
int maid(void) {
    // block-level scope
    if (1) {
        int x = 5;
        printf("x = %d\n", x);
    }
    
    printf("x = %d\n", x);
    // use of undeclared identifier 'x'
    return 0;
}
```

> 위의 C언어 코드를 보면 if문 내에서 선언된 변수 x는 if문 코드 블록 내에서만 유효하다. 즉, if문 코드 블록 밖에서는 참조가 불가능하다.



##### 자바스크립트와 함수 레벨 스코프

> 하지만 자바스크립트는 함수 레벨 스코프를(function-level scope) 따른다. 함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다는 것이다.



> ##### 예외 : let (ES6)
>
> 그러나 여기에도 예외가 있는데, ES6에서 도입된 `let` 키워드를 사용하면 블록 레벨 스코프를 사용할 수 있다.

> 다음 예시는 var와 let의 차이, 그리고 자바스크립트의 스코프의 특징을 명확히 나타낸다. var는 블록과 상관 없이 스코프가 적용되는 것을 확인할 수 있으며, let은 블록에 스코프가 제한되는 것을 확인할 수 있다.



> ##### var 예시

```javascript
var x = 0;
{
    var x = 1;
    console.log(x); // 1
}
console.log(x) // 1
```

> 위 예시에서 마지막 구문의 출력 결과는 1이다. 이러한 결과가 나오는 이유는 두 가지이다. 
>
> 먼저 하나는 자바스크립트는 기본적으로 함수 레벨 스코프를 갖기 때문에 코드 블록에 의해 스코프가 제한되지 않는다. 따라서 나중에 선언된 x도 전역에서 참조가 가능하다.
>
> 다른 하나는 var는 재선언과 재할당이 가능하다. 따라서 처음에 선언된 x대신 나중에 선언된 x가 참조된다.



> ##### let 예시

```javascript
let y = 0;
{
    let y = 1;
    console.log(y); // 1
}
console.log(y); // 0
```

> let은 블록 레벨 스코프를 갖는다. let은 기본적으로 재선언이 불가능하다. 그럼에도 위에서 에러가 나지 않는 이유는 let은 블록 레벨에 의해 스코프가 제한되므로 두 y가 코드 블록을 기준으로 구별되기 때문이다. 따라서 위에서 전역에서 선언된 y와 코드 블록 내에서 선언된 y는 다른 변수이다.
>
> 따라서 위의 첫 번째 출력 결과는 1이다. 이는 동일 블록 레벨에서의 y를 참조하기 때문이다. 두 번째 출력 결과는 0이다. 이는 전역에서 선언된  y를 참조하기 때문이다.



##### 전역 스코프

> 전역에 변수를 선언하면 이 변수는 어디에서든 참조 가능한 전역 변수가 된다. var 키워드로 선언한 전역 변수는 전역 객체(Global Object) window의 프로퍼티이다.

```javascript
var global = 'global';

function foo() {
    var local = 'local';
    console.log(global);
    console.log(local);
}
foo();

console.log(global);
console.log(local);
// Uncaught ReferenceError: local is not defined
```

> 변수 global은 함수 영역 밖의 전역에서 선언되었다. 자바스크립트는 타 언어와 달리 특별한 시작점(Entry Point)이 없어서 위 코드와 같이 전역에  변수나 함수를 선언하기 쉽다.
>
> C언어의 경우 main 함수가 시작점이 되기 때문에 대부분의 코드는 main 함수 내에 포함된다. C언어의 경우 전역 변수를 선언하기 위해 의도적으로 main 함수 밖에 변수를 선언해야 한다.
>
> 그런데 자바스크립트는 다른 C계열 언어와 다르게 특별한 시작점이 없으며 코드가 나타나는 즉시 해석되고 실행된다. 따라서 전역에 변수를 선언하기 쉬운데 이는 전역 변수를 남발하게 되는 문제를 야기시킨다.
>
> 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 사용을 억제해야 한다.



##### 비 블록 레벨 스코프 (Non Block-Level Scope)

```javascript
if (true) {
    var x = 5;
}
console.log(x);
```

> 변수 x는 코드 블록 내에서 선언되었다. 하지만 자바스크립트는 블록 레벨 스코프를 사용하지 않으므로 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 스코프를 갖게 된다. 따라서 변수 x는 전역 변수이다.



##### 함수 레벨 스코프 (Function-Level Scope)

```javascript
var a = 10; // 전역 변수

(function() {
    var b = 20;
})();

console.log(a); // 10
console.log(b); 
// Uncaught ReferenceError: b is not defined
```

> 대신 자바스크립트에서는 함수 레벨 스코프가 존재한다. 함수 내부에 선언된 매개변수와 변수는 외부에서 참조할 수 없다. 따라서 위의 예시에서 b를 참조하려 하자 에러가 난것을 확인할 수 있다.



> ##### 동일한 이름으로 중복 선언된 변수에 대한 참조 우선순위
>
> 자바스크립트에선 함수가 스코프의 구분 기준이 된다. 따라서 함수의 존재로 인해 둘 이상의 변수의 스코프가 서로 다르다면, 동일한 식별자명을 갖는 둘 이상의 변수에 대한 중복 선언도 가능하다. 
>
> 이런 경우 해당 변수들에 참조에 대해서는 스코프의 규칙을 따르게 된다. 전역에서는 전역 변수만이 참조 가능하다. 지역에서는 지역 변수와 전역 변수 모두 참조 가능하지만 지역 변수를 우선하여 참조한다.
>
> 예시는 다음과 같다.

```javascript
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x);
}

foo();          // local
console.log(x); // global
```

> 또 다른 예시는 다음과 같다. 함수가 중첩되어도 스코프의 규칙은 동일하게 적용됨을 알 수 있다.

```javascript
var x = 'global';

function foo() {
    var x = 'local';
    console.log(x);		// local
    
    function bar() {	// 내부함수
        console.log(x); // local
    }
    
    bar();
}

foo();
console.log(x);		// global
```

> 내부함수는 자신을 포함한 외부함수의 변수에 접근할 수 있다. 이는 매우 유용하다. 클로저에서와 같이 내부함수가 더 오래 생존하는 경우, 타 언어와는 다른 움직임을 보인다.
>
> 함수 bar에서 참조하는 변수 x는 함수 foo에서 선언된 지역변수이다. 이는 실행 컨텍스트의 스코프 체인에 의해 참조 순위에서 전역변수 x가 뒤로 밀렸기 때문이다.



> ##### 상위 스코프의 변수 참조 예시
>
> 다음의 예시는 함수 블록 내에서 전역 변수에 참조할 수 있음을 보여준다.

```javascript
var x = 10;

function foo() {
    x = 100;
    console.log(x);
}

foo();
console.log(x); // 100
```

> 함수 영역에서 전역 변수를 참조할 수 있으므로 위와 같이 전역 변수의 값도 변경이 가능하다. 내부 함수의 경우, 전역 변수는 물론 상위 함수에서 선언한 변수에 접근 및 변경이 가능하다.
>
> 다음은 상위 함수에 선언한 변수를 참조하는 예시이다.

```javascript
var x = 10;

function foo() {
    var x = 100;
    console.log(x); // 100
    
    function bar() {
        x = 1000;
        console.log(x); // 1000
    }
    
    bar();
}

foo();
console.log(x); // 10
```

> 스코프가 중첩되어 있을 경우 인접한 상위의 스코프를 우선적으로 탐색하여 참조한다.
>
> 이제 다음과 같은 복잡한 예시에서도 각 변수의 스코프가 어떻게 동작하는지 알 수 있을 것이다.

```javascript
var foo = function() {
    var a = 3, b = 5;
    // 변수 a, b가 선언되며 a는 3, b는 5이다.
    
    var bar = function() {
        var b = 7, c = 11;
        // 내부함수이므로 새로운 b가 선언된다. 이 b는 7이다.
        // c는 11이다.
        
        a += b + c;
        // 외부함수 a를 참조할 수 있다. a에 (7+11)의 값을 더한다.
        // 더한 결과 a는 21이 된다.
    };
    // 아직 내부 함수 bar가 실행되지 않았다.
    // 따라서 아직 a는 3이다. b는 5이다. c는 참조 불가능하다.
    
    bar();
    console.log(c);
    // 함수가 실행되었으므로 a는 21이다. b는 5이다.
    // c는 참조 불가능하다.
};
```



##### 렉시컬 스코프 (Lexical Scope)

> 렉시컬 스코프에 대해 알아보기 전에, 다음 예시의 실행 결과가 어떻게 될지 예측해보자.
>
> 예시는 다음과 같다.

```javascript
var x = 1;

function foo() {
    var x = 10;
    bar();
}

function bar() {
    console.log(x);
}

foo(); // ?
bar(); // ?
```

> 위 예시의 실행 결과는 함수 bar의 상위 스코프가 어떻게 결정되느냐에 따라 예측 결과도 다르다고 할 수 있다. 



> ##### 동적 스코프(Dynamic Scope)와 정적 스코프(Static Scope)
>
> 우선 첫 번째로 생각할 수 있는 것은 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정하는 방식이다. 이러한 방식에 따르면 함수 bar의 상위 스코프는 함수 foo와 전역 스코프가 될 것이다. 이런 경우 참조할 x의 값은 foo에 선언된 x의 값인 10으로 예측될 것이다.
>
> 두 번째로 생각할 수 있는 것은 함수의 선언된 위치에 따라 상위 스코프를 결정하는 방식이다. 이 경우 함수 bar의 상위 스코프는 전역 스코프가 될 것이다. 이런 경우 참조할 x의 값은 전역에 선언된 x의 값인 1로 예측될 것이다.
>
> 프로그래밍 언어는 이 두 가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다. 첫 번째 방식을 동적 스코프라 한다. 두 번째 방식을 정적 스코프라 한다. 렉시컬 스코프는 정적 스코프와 동일한 의미로, 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.



> ##### 자바스크립트와 렉시컬 스코프
>
> 따라서 자바스크립트에서 함수의 상위 스코프는 함수를 어디에서 선언하였는가에 따라 결정된다. 함수를 어디서 호출하였는지는 함수의 스코프 결정에 아무런 영향을 주지 않는다. 따라서 위 예시의 결과는 다음과 같다.

```javascript
foo(); // 1
bar(); // 1
```





#### 전역 변수의 위험성과 방지

------

##### 암묵적 전역 변수 (Implicit Global Variable)

> 암묵적 전역 변수란 사용자가 명시적으로 전역에 선언하지 않았음에도 암묵적으로 생성된 전역 변수를 의미한다. 이 말의 의미에 대해 살펴보기 전에 먼저 다음 예시의 결과를 예측해보자.

```javascript
function foo() {
    x = 10;
}

foo();
console.log(x); // ?
```

> 위의 예시에서 함수 foo에서는 변수 x에 10이란 값을 할당하도록 되어있다. 그런데 할당을 하기 위해선 먼저 선언된 변수 x를 참조할 수 있어야 할 것이다.
>
> 따라서 자바스크립트 엔진은 다음과 같이 동작한다. 먼저 함수 foo의 스코프에서 변수 x를 찾는다. 그런데 x가 foo의 스코프에 없으므로 스코프 체인에 의해 이제 전역 스코프에서 변수 x를 찾는다. 그런데 위 예시에서는 전역 스코프에도 x는 존재하지 않는다.
>
> 이러한 이유로 ReferenceError를 발생시킬 것으로 예측할 수 있다. 그런데 이 에러는 발생되지 않는다. 대신 전역 변수 x가 생성되며 값을 할당한다. 이처럼 var 키워드를 생략한 변수는 암묵적으로 전역 변수가 되는데, 이를 암묵적 전역 변수라 한다.
>
> 대부분의 암묵적 전역 변수는 개발자의 의도와 무관하게 동작한다. 따라서 오류의 발생원인이 될 가능성이 크다. 이를 방지하기 위해 변수 선언시에는 반드시 var와 같은 키워드를 사용해야 한다.



##### 전역 변수 사용에 따른 변수명 중복

> 아래와 같이 두 개의 분리된 자바스크립트 파일이 있다고 가정하자.

```javascript
// x.js
function foo() {
    i = 0; 		
    // var i = 0;
}
```

```javascript
// y.js
for (var i = 0; i < 5; i++) {
    foo();
    console.log(i);
}
```

> 이 예시에서 x.js와 y.js에는 모두 변수 i가 존재한다. 별도의 파일에서 x.js와 y.js가 로드되어 사용되는 경우에는 이 예시 코드는 어떤 문제도 일으키지 않을 것이다. 
>
> 다음의 예시에서는 어떨까?

```html
<!DOCTYPE html>
<html>
<body>
  <script src='x.js'></script>
  <script src='y.js'></script>
</body>
</html>
```

> 동일한 HTML 파일에서 x.js와 y.js의 두 자바스크립트 파일을 로드하면 변수 i가 중복된다. 이는 아마도 개발자가 의도하지 않은 상황일 것이다.
>
> 위와 같은 상황에서 x.js에 선언된 변수 i는 var 키워드를 사용하지 않았으므로 암묵적 전역 변수가 된다. y.js의 변수 i 역시 전역변수이다. 자바스크립트에서는 코드 블록에 의해 스코프가 제한되지 않기 때문이다. 따라서 for 반복문을 돌 때마다 함수 foo가 호출되고, 전역 변수 i의 값을 0으로 초기화된다. 결국 for 반복문은 무한 루프 상태에 빠진다.
>
> 이처럼 전역 변수는 개발자가 의도하지 않은 동작의 원인이 된다. 따라서 전역 변수를 반드시 사용할 이유가 없다면, 지역 변수를 사용하는 것이 좋다. 변수의 스코프는 좁을 수록 좋다.



##### 최소한의 전역 변수 사용

> 더글라스 크락포드의 제안에 따르자면, 전역 변수의 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역 변수 사용을 위해 다음과 같이 객체 하나를 만들어 사용하는 것이다. 

```javascript
var MYAPP = {};

MYAPP.student = {
    name: 'Lee',
    gender: 'male'
};

console.log(MYAPP.student.name);
```



##### 즉시실행함수를 이용한 전역 변수 사용 억제

> 전역 변수 사용을 억제하기 위해 즉시 실행 함수를 사용할 수 있다. 이 방법을 사용하면 전역변수를 만들지 않으므로 라이브러리 등에 자주 사용된다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다.

```javascript
(function () {
  var MYAPP = {};

  MYAPP.student = {
    name: 'Lee',
    gender: 'male'
  };

  console.log(MYAPP.student.name); // Lee
}());

console.log(MYAPP.student.name);
// Uncaught ReferenceError: MYAPP is not defined
```

